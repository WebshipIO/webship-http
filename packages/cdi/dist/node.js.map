{"version":3,"sources":["node.ts"],"names":[],"mappings":";;AAWA,MAAa,qBAAqB;IAAlC;QACU,QAAG,GAAyD,IAAI,GAAG,EAAE,CAAA;IA2D/E,CAAC;IAzDQ,GAAG,CAAC,IAAa,EAAE,QAAyB;QACjD,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACtB,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;YAC9B,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;aACpB;iBAAM;gBACL,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAA;aACzC;SACF;aAAM;YACL,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;SAC7B;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEM,GAAG,CAAC,IAAa;QACtB,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEM,GAAG,CAAC,IAAa;QACtB,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEM,MAAM,CAAC,IAAa;QACzB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAA;IAClB,CAAC;IAEM,IAAI;QACT,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAA;IACtB,CAAC;IAEM,CAAE,MAAM;QACb,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE;YACnC,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;oBACnB,MAAM,CAAC,CAAA;iBACR;aACF;iBAAM;gBACL,MAAM,KAAK,CAAA;aACZ;SACF;IACH,CAAC;IAEM,CAAE,OAAO;QACd,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE;YAC3C,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;oBACnB,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;iBACf;aACF;iBAAM;gBACL,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;aACnB;SACF;IACH,CAAC;CACF;AA5DD,sDA4DC","file":"node.js","sourcesContent":["/*\n  这个模块定义了 Node 。和其他依赖注入或者 IOC 框架不同，在 webnode CDI 中，依赖注入受到严格的控制。只有\n  标记为 Node 的类才会执行依赖注入。这样做是为了将依赖注入的影响减小到最小范围，以提供更好的性能和可维护性，\n  因为，大多数时候你只需要为类似 root 之类的类注入依赖。\n*/\n\nimport {ClassType} from './types'  \n\nexport type Node<T = any> = ClassType<T>  \nexport type NodeInstance<T extends Node = any> = InstanceType<T> & NonNullable<Object>\n\nexport class NodeInstanceContainer<T extends Node = any> {\n  private map: Map<Node<T>, NodeInstance<T> | Set<NodeInstance<T>>> = new Map()\n\n  public add(node: Node<T>, instance: NodeInstance<T>): this {\n    if (this.map.has(node)) {\n      let value = this.map.get(node)\n      if (value instanceof Set) {\n        value.add(instance)\n      } else {\n        this.map.set(node, new Set().add(value))\n      }\n    } else {\n      this.map.set(node, instance)\n    }\n    return this\n  }\n\n  public get(node: Node<T>): NodeInstance<T> | Set<NodeInstance<T>> {\n    return this.map.get(node)\n  }\n\n  public has(node: Node<T>): boolean {\n    return this.map.has(node)\n  }\n\n  public delete(node: Node<T>) {\n    this.map.delete(node)\n  }\n\n  public clear() {\n    this.map.clear()\n  }\n\n  public size(): number {\n    return this.map.size\n  }\n\n  public * values(): Iterable<NodeInstance<T>> {\n    for (let value of this.map.values()) {\n      if (value instanceof Set) {\n        for (let a of value) {\n          yield a\n        }\n      } else {\n        yield value\n      }\n    }\n  }\n\n  public * entries(): Iterable<[Node<T>, NodeInstance<T>]> {\n    for (let [key, value] of this.map.entries()) {\n      if (value instanceof Set) {\n        for (let v of value) {\n          yield [key, v]\n        }\n      } else {\n        yield [key, value]\n      }\n    }\n  }\n}"]}