{"version":3,"sources":["node.ts"],"names":[],"mappings":";;AAKA,MAAa,qBAAqB;IAAlC;QACU,QAAG,GAAyD,IAAI,GAAG,EAAE,CAAA;IAwD/E,CAAC;IAtDQ,GAAG,CAAC,IAAa,EAAE,QAAyB;QACjD,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACtB,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;YAC9B,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;aACpB;iBAAM;gBACL,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAC5B;gBAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAA0B,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;aACzD;SACF;aAAM;YACL,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;SAC7B;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEM,GAAG,CAAC,IAAa;QACtB,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEM,GAAG,CAAC,IAAa;QACtB,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC3B,CAAC;IAEM,MAAM,CAAC,IAAa;QACzB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAA;IAClB,CAAC;IAEM,CAAE,MAAM;QACb,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE;YACnC,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;oBACnB,MAAM,CAAC,CAAA;iBACR;aACF;iBAAM;gBACL,MAAM,KAAK,CAAA;aACZ;SACF;IACH,CAAC;IAEM,CAAE,OAAO;QACd,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,EAAE;YAC3C,IAAI,KAAK,YAAY,GAAG,EAAE;gBACxB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE;oBACnB,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;iBACf;aACF;iBAAM;gBACL,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;aACnB;SACF;IACH,CAAC;CACF;AAzDD,sDAyDC","file":"node.js","sourcesContent":["import {ClassType} from './types'  \n\nexport type Node<T=any> = ClassType<T>  \nexport type NodeInstance<T extends Node =any> = InstanceType<T> & NonNullable<Object>\n\nexport class NodeInstanceContainer<T extends Node=any> {\n  private map: Map<Node<T>, NodeInstance<T> | Set<NodeInstance<T>>> = new Map()\n\n  public add(node: Node<T>, instance: NodeInstance<T>): this {\n    if (this.map.has(node)) {\n      let value = this.map.get(node)\n      if (value instanceof Set) {\n        value.add(instance)\n      } else {\n        this.map.set(node, new Set())\n        ;(this.map.get(node) as Set<NodeInstance<T>>).add(value)\n      }\n    } else {\n      this.map.set(node, instance)\n    }\n    return this\n  }\n\n  public get(node: Node<T>): NodeInstance<T> | Set<NodeInstance<T>> {\n    return this.map.get(node)\n  }\n\n  public has(node: Node<T>): boolean {\n    return this.map.has(node)\n  }\n\n  public delete(node: Node<T>) {\n    this.map.delete(node)\n  }\n\n  public clear() {\n    this.map.clear()\n  }\n\n  public * values(): Iterable<NodeInstance<T>> {\n    for (let value of this.map.values()) {\n      if (value instanceof Set) {\n        for (let a of value) {\n          yield a\n        }\n      } else {\n        yield value\n      }\n    }\n  }\n\n  public * entries(): Iterable<[Node<T>, NodeInstance<T>]> {\n    for (let [key, value] of this.map.entries()) {\n      if (value instanceof Set) {\n        for (let a of value) {\n          yield [key, a]\n        }\n      } else {\n        yield [key, value]\n      }\n    }\n  }\n}\n\n\n\n\n\n"]}