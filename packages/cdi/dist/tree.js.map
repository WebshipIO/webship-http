{"version":3,"sources":["tree.ts"],"names":[],"mappings":";;AAAA,MAAa,QAAQ;IAKZ,SAAS,CAAC,MAAmB;QAClC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;IACtB,CAAC;IAEM,SAAS;QACd,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC;IAEM,YAAY;QACjB,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;IACxC,CAAC;IAEM,SAAS;QACd,OAAO,IAAI,CAAC,MAAM,YAAY,QAAQ,CAAA;IACxC,CAAC;IAEM,QAAQ,CAAC,KAAmB;QACjC,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAA;SAC1B;QACD,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,KAAK,GAAG,IAAI,QAAQ,EAAE,CAAA;SACvB;QACD,KAAK,CAAC,MAAM,GAAG,IAAI,CAAA;QACnB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;QACxB,OAAO,KAAK,CAAA;IACd,CAAC;IAEM,WAAW,CAAC,KAAkB;QACnC,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;IAC5D,CAAC;IAEM,QAAQ,CAAC,KAAkB;QAChC,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;IAChE,CAAC;IAEM,CAAE,gBAAgB;QACvB,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC/B,MAAM,KAAK,CAAA;aACZ;SACF;IACH,CAAC;IAEM,CAAE,MAAM;QACb,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;YAC/B,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC/B,MAAM,KAAK,CAAC,KAAK,CAAA;aAClB;SACF;IACH,CAAC;IAEM,cAAc;QACnB,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAA;IAC7D,CAAC;IAEM,aAAa;QAClB,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAA;IACtD,CAAC;CACF;AAhED,4BAgEC","file":"tree.js","sourcesContent":["export class TreeNode<T> {\n  private parent?: TreeNode<T>\n  private children?: Set<TreeNode<T>>\n  public  value: T\n\n  public setParent(parent: TreeNode<T>) {\n    this.parent = parent\n  }\n\n  public getParent(): TreeNode<T> {\n    return this.parent\n  }\n\n  public deleteParent() {\n    Reflect.deleteProperty(this, 'parent')\n  }\n\n  public hasParent(): boolean {\n    return this.parent instanceof TreeNode\n  }\n\n  public addChild(child?: TreeNode<T>): TreeNode<T> {\n    if (this.children === undefined) {\n      this.children = new Set()\n    }\n    if (child === undefined) {\n      child = new TreeNode()\n    }\n    child.parent = this\n    this.children.add(child)\n    return child\n  }\n\n  public deleteChild(child: TreeNode<T>) {\n    this.children !== undefined && this.children.delete(child)\n  }\n\n  public hasChild(child: TreeNode<T>): boolean {\n    return this.children !== undefined && this.children.has(child)\n  }\n\n  public * valuesOfChildren(): Iterable<TreeNode<T>> {\n    if (this.children !== undefined) {\n      for (let child of this.children) {\n        yield child\n      }\n    }\n  }\n\n  public * values(): Iterable<T> {\n    if (this.children !== undefined) {\n      for (let child of this.children) {\n        yield child.value\n      }\n    }\n  }\n\n  public sizeOfChildren(): number {\n    return this.children === undefined ? 0 : this.children.size\n  }\n\n  public clearChildren() {\n    this.children !== undefined && this.children.clear()\n  }\n}\n\n"]}