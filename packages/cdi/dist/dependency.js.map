{"version":3,"sources":["dependency.ts"],"names":[],"mappings":"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","file":"dependency.js","sourcesContent":["/*\n  只能使用参数绑定依赖，这是因为　TypeScript 无法获取类的成员属性表，当编译后，未赋值的属性会被\n  忽略。所以，绑定只能出现在构造函数或者成员方法的参数：\n\n      class Test {\n        constructor(\n          @ApplicationScope('user') user: User\n        ) {\n        }\n\n        print(@ApplicationScope('user') user: User) {\n  \n        }\n      }\n*/\n\nimport {ClassType} from './types'\nimport {Scope} from './scope'\nimport {Provider, ProviderInstance, ProviderKey} from './provider'\nimport {Node} from './node'\nimport 'reflect-metadata'\n\nexport interface Dependency {\n  providerKey: ProviderKey\n  providerType: ClassType\n  scope: Scope\n  parameterIndex: number\n}\n\nexport class DependencyContainer {\n  private static sInstance: DependencyContainer\n\n  public static get instance(): DependencyContainer {\n    if (DependencyContainer.sInstance === undefined) {\n      DependencyContainer.sInstance = new DependencyContainer()\n    }\n    return DependencyContainer.sInstance\n  }\n  \n  private map: Map<Node, Map<PropertyKey, Array<Dependency>>> = new Map()\n\n  public set<T>(node: Node<T>, propertyKey: PropertyKey, parameterIndex: number, providerKey: ProviderKey, scope: Scope) {\n    if (!this.map.has(node)) {\n      this.map.set(node, new Map())\n    }\n    let dependency = {\n      providerKey: providerKey,\n      providerType: Reflect.getMetadata(\"design:type\", node.prototype, propertyKey as string | symbol),\n      scope: scope,\n      parameterIndex: parameterIndex\n    }\n    let submap = this.map.get(node)\n    if (!submap.has(propertyKey)) {\n      submap.set(propertyKey, [])\n    }\n    submap.get(propertyKey)[parameterIndex] = dependency\n  }\n\n  public get<T>(node: Node<T>, propertyKey: PropertyKey): Array<Dependency> {\n    if (this.map.has(node) && this.map.get(node).has(propertyKey)) {\n      return this.map.get(node).get(propertyKey)\n    }\n    return []\n  }\n\n  public has<T>(node: Node<T>, propertyKey: PropertyKey): boolean {\n    return this.map.has(node) && this.map.get(node).has(propertyKey)\n  }\n\n  public delete<T>(node: Node<T>, propertyKey?: PropertyKey) {\n    if (this.map.has(node)) {\n      if (arguments.length > 1) {\n        if (this.map.get(node).has(propertyKey)) {\n          this.map.get(node).delete(propertyKey)\n        }\n      } else {\n        this.map.delete(node)\n      }\n    }\n  }\n\n  public clear() {\n    this.map.clear()\n  }\n\n  public size<T>(node?: Node<T>): number {\n    if (arguments.length > 1) {\n      if (this.map.has(node)) {\n        return this.map.get(node).size\n      } else {\n        return 0\n      }\n    } else {\n      return this.map.size\n    }\n  }\n\n  public * values<T>(node: Node<T>, propertyKey: PropertyKey): Iterable<Dependency> { \n    // 依赖只关注当前节点本身，而不灌注父类（如果继承的话）\n    if (this.map.has(node)) {\n      let propertyKeyMap = this.map.get(node)\n      if (propertyKeyMap.has(propertyKey)) {\n        for (let dependency of propertyKeyMap.get(propertyKey)) {\n          if (dependency !== undefined) {\n            yield dependency\n          }\n        }\n      }\n    }\n  }\n\n  public * entries<T>(): Iterable<[Node, PropertyKey, Dependency]> { \n    // 依赖只关注当前节点本身，而不灌注父类（如果继承的话）\n    for (let [node, propertyKeyMap] of this.map.entries()) {\n      for (let [propertyKey, dependencies] of propertyKeyMap.entries()) {\n        for (let dependency of dependencies) {\n          if (dependency !== undefined) {\n            yield [node, propertyKey, dependency]\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction * chainClassType(x: ClassType): Iterable<ClassType> {\n  // iterate over the inheritance class chain of a class ``x``, including its own class.\n  // such as a class chain ``A -|> B -|> C``, return ``A`` ``B`` ``C`` when ``chainClassTypes(A)``\n  //\n  // Function.__proto__ === Object.__proto__ === Function.prototype\n  // C.__proto__        === Function.__proto__ \n  // B.__proto__        === A\n  // A.__proto__        === B\n  let constructs: Array<ClassType> = [x]\n  for (let c of constructs) {\n    yield c\n    let next = Object.getPrototypeOf(c)\n    if (next === Function.prototype) {\n      break\n    }\n    constructs.push(next)\n  }\n}\n"]}